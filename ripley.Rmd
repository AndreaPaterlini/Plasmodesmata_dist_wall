---
title: "Alternative approaches"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
---

<!-- Load Zooming library that will enable to click on images and zoom them -->
<script src="https://unpkg.com/zooming/build/zooming.min.js"></script>

<script>
// Listen to images after DOM content is fully loaded
document.addEventListener('DOMContentLoaded', function () {
new Zooming({
// options...
}).listen('.img-zoomable')
})
</script>

<br>

In the paper we provided *one* pipeline for the analysis of the data generated by the plugins. Many other approaches are in principle possible and are actually warmly invited. In response to a reviewer's suggestion, here we show an alternative strategy for the analysis of PD distributions. This approach employs Ripley's K function implemented in the [spatstat package](https://cran.r-project.org/web/packages/spatstat/index.html). We highlight advantages and pitfalls. Overall, if this approach was to be implemented in the future, it will require, for precision, the spatial edges of the segmented wall and, for robustness, effect size assessments.

<br>

# Exploring an example of real data at PPP-EN

<br>

At this interface in the paper, using Euclidean distances and KS tests, we had detected clustering of PDs. Ripley's K test, as shown below, seems to agree with this result. Please note that it was run on a single cell and not on the entire dataset.

<br>

```{r, message=FALSE, warning= FALSE}

library(tidyverse)
library(broom)

setwd('./Data_individual_cells')

PPP_example_real <- read_csv("170314_Col_HD_R20_339-381um_DNN_PPP1-EN_Ann.csv") %>% 
      as.data.frame %>% 
      select(c(LabelPositionXunits, LabelPositionYunits, LabelPositionZunits)) %>% 
      rename("X_units"="LabelPositionXunits") %>%
      rename("Y_units"="LabelPositionYunits") %>%
      rename("Z_units"="LabelPositionZunits") %>%
      mutate(Genotype = "Col-0") %>%
      mutate(DatasetFilename = "170314_Col_HD_R20_339-381um_DNN_PPP1-EN") %>%
      mutate(Interface = "PPP-EN") %>%
      mutate(IterationNumber = "real")

# we first perform a pca, reducing our data to a 2D situation
# we scale the data 

PPP_example_real_pca <- PPP_example_real %>% select(X_units, Y_units, Z_units) %>% prcomp(scale. = TRUE)

# we can check that the PCA is not causing a signicant loss of information

tidy(PPP_example_real_pca, matrix = "pcs") %>% print() 
# more than 90% retained in all cases in the first two dimentions

# we attach the pca columns contained in pca object to the original data
# 1 and 2 only take the first two PCAs, we are not attaching third PCA

PPP_example_real <- cbind(PPP_example_real, PPP_example_real_pca$x[, 1:2])

# to use Ripley's K test we need to load the spatstat package

#install.packages("spatstat")
library(spatstat)

# we then need to create a spatial object with the ppp function that includes the x and y coordinates of the points (here PC1 and PC2) and also the overall space the points sit in. Because the the segmented wall cannot be easily imported in R here we need to use an approximation of the space obtained with max() and min() functions on PC1 and PC2
# THIS IS NOT STRICTLY SPEAKING PRECISE and it is why we favoured the Euclidean distances approach in the paper, as that approach does not require any surface information.
# Please remember this limitation is using this

PPP_example_real_pattern <- ppp(PPP_example_real$PC1, PPP_example_real$PC2, c(min(PPP_example_real$PC1),max(PPP_example_real$PC1)), c(min(PPP_example_real$PC2),max(PPP_example_real$PC2)))

# we can summarise the obtained spatial area

summary(PPP_example_real_pattern)

# we now run the Ripley's test
# we use envelope function rather than the Kest one alone to additionally determine the significance of the patterns. The function simulates some number of datasets (nsim = ...) by permuting the locations of input data and then obtaining the range of K values across a range of distances for each permuted dataset. The gray area obtained will represent the 95% confidence intervals for complete spatial randomness based on these simulations of data. The correction argument incorporates an edge correction with different potential models 

plot(envelope(PPP_example_real_pattern, Kest), main="Example real data at PPP-EN interface")

# the black line represents our data
# the red line the theoretical spatial randomness 
# the grey area the confidence intervals as mentioned

```

<br>

# Exploring simulated data at the PPP-EN interface

<br>

Ripley's K test does not require our simulated data. This would be a computational advantage. Nonetheless, we run the test on some simulations. We expected them to act as negative controls (as *we know* these distributions have been sampled from uniform distibutions). Here we encountered some concerns: while in some simulations (#45) the test did not detect clustering (as expected) in others (#1) weak signatures of clustering were detected. 

This is not fully surprising as even “random” data can experience phenomena like Poisson clumping. In addition, the boundary space between the real and simulated data (and also between different simulated data for the same cell) can be slightly different due to the min() and max() functions being used. This could cause effects we don’t fully control or forecast. That is a limitation of being unable to import the segmented wall as a spatial object.

However, these results makes us question the direct use of Ripley's K on real data alone. They rather suggest that employing Ripley’s K might require more quantitative assessments. For instance, one could try to calculate the K curve for each simulation and see if the curve for the real data is always above the simulated ones (arching more). We invite people interested in using this function to consider this.

<br>

```{r, warning= FALSE, message=FALSE}

setwd('./Data_individual_cells')

PPP_example_simulated <- read_csv("170314_Col_HD_R20_339-381um_DNN_PPP1-EN_random_points.csv") %>% 
      as.data.frame %>% 
      mutate(Genotype = "Col-0") %>%
      mutate(DatasetFilename = "170314_Col_HD_R20_339-381um_DNN_PPP1-EN") %>%
      mutate(Interface = "PPP-EN")

# we now select two different simulation

PPP_example_simulated_45 <- filter(PPP_example_simulated, IterationNumber=="45")

PPP_example_simulated_1 <- filter(PPP_example_simulated, IterationNumber=="1")

PPP_example_simulated_45_pca <- PPP_example_simulated_45 %>% select(X_units, Y_units, Z_units) %>% prcomp(scale. = TRUE)

PPP_example_simulated_1_pca <- PPP_example_simulated_1 %>% select(X_units, Y_units, Z_units) %>% prcomp(scale. = TRUE)

tidy(PPP_example_simulated_45_pca, matrix = "pcs") %>% print() 

tidy(PPP_example_simulated_1_pca, matrix = "pcs") %>% print()

PPP_example_simulated_45 <- cbind(PPP_example_simulated_45, PPP_example_simulated_45_pca$x[, 1:2])

PPP_example_simulated_1 <- cbind(PPP_example_simulated_1, PPP_example_simulated_1_pca$x[, 1:2])

PPP_example_simulated_45_pattern <- ppp(PPP_example_simulated_45$PC1, PPP_example_simulated_45$PC2, c(min(PPP_example_simulated_45$PC1),max(PPP_example_simulated_45$PC1)), c(min(PPP_example_simulated_45$PC2),max(PPP_example_simulated_45$PC2)))

PPP_example_simulated_1_pattern <- ppp(PPP_example_simulated_1$PC1, PPP_example_simulated_1$PC2, c(min(PPP_example_simulated_1$PC1),max(PPP_example_simulated_1$PC1)), c(min(PPP_example_simulated_1$PC2),max(PPP_example_simulated_1$PC2)))

summary(PPP_example_simulated_45_pattern)

summary(PPP_example_simulated_1_pattern)

plot(envelope(PPP_example_simulated_45_pattern, Kest, correction="best", nsim = 1000), main="Example simulated data #45 at PPP-EN interface")

plot(envelope(PPP_example_simulated_1_pattern, Kest, correction="best", nsim = 1000), main="Example simulated data #1 at PPP-EN interface")

```