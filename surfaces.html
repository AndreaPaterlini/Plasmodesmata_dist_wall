<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Surface areas</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<div class="container-fluid main-container">

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Data analysis</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Welcome</a>
</li>
<li>
  <a href="preliminary.html">Preliminary steps</a>
</li>
<li>
  <a href="distributions.html">Distributions</a>
</li>
<li>
  <a href="clusters.html">Clusters</a>
</li>
<li>
  <a href="surfaces.html">Surfaces</a>
</li>
<li>
  <a href="wall.html">Cell wall</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Surface areas</h1>

</div>


<p><br></p>
<p>In this section we continue to ask questions about the distribution of Plasmodesmata (or similar types of annotations along a given model). We continue to use the output of the Spatial control plugin shown in the <a href="#distributions.html">Distributions section</a>. Since we previously detected a bias in the distribution of Plasmodesmata, strongly hinting at the presence of spatial clustering, and we then quantified the number of these clusters of plasmodesmata we now ask: <strong>What proportions of the cellular surface do these clusters occupy?</strong></p>
<p><br></p>
<div id="exploring-the-data" class="section level1">
<h1>Exploring the data</h1>
<p><br></p>
<pre class="r"><code>library(tidyverse)
library(broom)
#library(splancs) called in the function so no need to load it
#library(ggbeeswarm) called in the function so no need to load it

# we loook at one one cell as an example
# please note that the clusters object is being carried over from the analysis that was performed in previous sections

cluster_example &lt;- clusters %&gt;% filter(DatasetFilename == &quot;170314_Col_HD_R20_339-381um_DNN&quot; &amp; Cell == &quot;PPP1-EN&quot;)

# we are going to largely replicate the workings of the fviz_clust function used in clusters section. There these steps were done implicitly by the functions but here we make the steps apparent and we extract data

# we first perform a pca, reducing our data to a 2D situation
# we scale the data to match what was done by the fviz_clust function. Note that this is not strictly necessary but more for graphical matching purposes. Clusters can be recognised in both cases. The scaling can also be turned off in the fviz_clust command. Either way the scaling effect seems negligible

cluster_pca &lt;- cluster_example %&gt;% select(X_units, Y_units, Z_units) %&gt;% prcomp(scale. = TRUE)

# we can check that the PCA is not causing a signicant loss of information

tidy(cluster_pca, matrix = &quot;pcs&quot;) %&gt;% print() </code></pre>
<pre><code>## # A tibble: 3 x 4
##      PC std.dev percent cumulative
##   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;
## 1     1   1.54  0.785        0.785
## 2     2   0.784 0.205        0.990
## 3     3   0.172 0.00983      1</code></pre>
<pre class="r"><code># more than 90% retained in all cases in the first two dimentions

# we attach the pca columns contained in pca object to the original data
# 1 and 2 only take the first two PCAs, we are not attaching third PCA

cluster_example &lt;- cbind(cluster_example, cluster_pca$x[, 1:2]) %&gt;% 
  # we also order the numbers of clusters for that well so that they will appear in a logical order in the legend 
  mutate(.cluster = factor(.cluster, levels = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;,&quot;7&quot;,&quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;11&quot;))) %&gt;% 
  mutate(.class = factor(.class, levels = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;,&quot;7&quot;,&quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;)))

# we use now use the chull function
# it finds the rows that contain the points (and the coordinates) that describe the edges of the poligon that could be drawn around each cluster
# to isolate those rows we use the function slice
# we group by cluster to obtain the single areas or we don&#39;t to obtain the full surface of the cell 

cluster_chull_sil &lt;- cluster_example %&gt;% 
  group_by(.cluster) %&gt;% 
  slice(chull(PC1, PC2))

cluster_chull_class &lt;- cluster_example %&gt;% 
  group_by(.class) %&gt;% 
  slice(chull(PC1, PC2))

total_chull &lt;- cluster_example %&gt;% 
  slice(chull(PC1, PC2))

# we visualise the results, in this case for the silhouette method

ggplot(cluster_example, aes(PC1, PC2)) +
  geom_point(data = cluster_example, aes(colour=.cluster, fill=.cluster)) +
  geom_polygon(data = total_chull, alpha = 0.09) +
  geom_polygon(data = cluster_chull_sil, aes(colour=.cluster, fill = .cluster), alpha = 0.3) +
  xlab(&quot;PC1 (78.5%)&quot;) + ylab(&quot;PC2 (20.5%)&quot;) +
  labs(fill = &quot;Silhouette \n clusters&quot;, colour = &quot;Silhouette \n clusters&quot;)</code></pre>
<p><img src="surfaces_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<pre class="r"><code># you will notice that this is nearly identical to the fviz function results
# by using .class instead you would get the results according to the McLust function

# now we want to calculate areas
# we  created a small function that uses the areapl from the splancs library

cha &lt;- function(x,y){
  i &lt;- chull(x,y)
  return(splancs::areapl(cbind(x[i],y[i])))
}

cluster_example %&gt;% 
  mutate(total_area = cha(PC1, PC2)) %&gt;% 
  group_by(.cluster) %&gt;% 
  summarise(area = cha(PC1, PC2), total_area = unique(total_area)) %&gt;%
  head()</code></pre>
<pre><code>## # A tibble: 6 x 3
##   .cluster   area total_area
##   &lt;fct&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1 1        0.0292       12.6
## 2 2        0.0577       12.6
## 3 3        0.365        12.6
## 4 4        0.317        12.6
## 5 5        0.359        12.6
## 6 6        0.167        12.6</code></pre>
<pre class="r"><code># do note that the units of these values are not strictyly speaking conventional surface units as the coordinates underwent a pca. We address this aspect in following steps</code></pre>
<p><br></p>
</div>
<div id="compiling-the-data" class="section level1">
<h1>Compiling the data</h1>
<p><br></p>
<pre class="r"><code># to process multiple cells in one go we write a larger function encompassing the steps described above 

calculate_areas_sil &lt;- function(x){
  
  # Run PCA
  x_pca &lt;- x %&gt;% 
    select(X_units, Y_units, Z_units) %&gt;% 
    prcomp(scale. = TRUE)
  
  # bind first two PCs
  x &lt;- cbind(x, x_pca$x[, 1:2])
  
  # calculate area of each cluster (here we do it for the silhouette method)
  area_of_clusters &lt;- x %&gt;% 
    group_by(.cluster) %&gt;% 
    summarise(area = cha(PC1, PC2))
  
  # add total area
  area_of_clusters$total_area &lt;- cha(x$PC1, x$PC2)
  
  #add sum of the areas of clusters
  area_of_clusters$sum_area &lt;- sum(area_of_clusters$area)
  
  #percentage conductive surface (of the total)
  area_of_clusters$perc_tot &lt;- area_of_clusters$sum_area/area_of_clusters$total_area*100
  
  #percentage of surface of each cluster 
  area_of_clusters$perc &lt;- area_of_clusters$area/area_of_clusters$total_area*100
  
  return(area_of_clusters)
}

# a nearly identical second function is created for the Mclust method

calculate_areas_class &lt;- function(x){
  
  x_pca &lt;- x %&gt;% 
    select(X_units, Y_units, Z_units) %&gt;% 
    prcomp(scale. = TRUE)
  x &lt;- cbind(x, x_pca$x[, 1:2])
  
  # we use .class instead
  area_of_clusters &lt;- x %&gt;% 
    group_by(.class) %&gt;% 
    summarise(area = cha(PC1, PC2))
  
  area_of_clusters$total_area &lt;- cha(x$PC1, x$PC2)
  
  area_of_clusters$sum_area &lt;- sum(area_of_clusters$area)
  
  area_of_clusters$perc_tot &lt;- area_of_clusters$sum_area/area_of_clusters$total_area*100
  
  area_of_clusters$perc &lt;- area_of_clusters$area/area_of_clusters$total_area*100
  
  return(area_of_clusters)
}

# we apply it and we nest the results

clusters_processed &lt;- clusters %&gt;% 
  group_by(DatasetFilename, Genotype, Interface, Cell) %&gt;% 
  nest() %&gt;% 
  mutate(cluster_sil_areas = lapply(data, calculate_areas_sil)) %&gt;% 
  mutate(cluster_class_areas = lapply(data, calculate_areas_class))

# we then unnest separately the results for either method

area_for_method_sil &lt;- clusters_processed %&gt;% 
  unnest(cluster_sil_areas) %&gt;% 
  mutate(Method = &quot;Silhouette&quot;)

area_for_method_class &lt;- clusters_processed %&gt;% 
  unnest(cluster_class_areas) %&gt;% 
  mutate(Method = &quot;Mclust&quot;)

# we then merge them

clusters_unnested &lt;- bind_rows(area_for_method_class, area_for_method_sil)</code></pre>
<p><br></p>
</div>
<div id="calculating-the-median-total-conductive-surface-of-an-interface-as" class="section level1">
<h1>Calculating the median total conductive surface of an interface (as %)</h1>
<p><br></p>
<pre class="r"><code># we now ask how much of the total surface (the gray shaded area we calculated in previous steps) is occupied by PD clusters

# for plotting you need to isolate the unique value for each cell (otherwise each cluster will be counted as a point altering the shape of distribution).
#the easiest way is to subset the dataset only for relevant columns and then use unique

ggplot(data=unique(clusters_unnested[, c(&quot;Genotype&quot;, &quot;Interface&quot;, &quot;DatasetFilename&quot;, &quot;Cell&quot;, &quot;perc_tot&quot;, &quot;Method&quot;)]), aes(x= Method, y=perc_tot, colour= Genotype, fill= Genotype)) +
    # we use shape = to characterise the points according to which root (datset they belong to)
  ggbeeswarm::geom_quasirandom(aes(shape=DatasetFilename,group=Genotype), size= 4, alpha=0.5, width=0.1, show.legend = FALSE, dodge.width = 0.9) +
  stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
               geom = &quot;crossbar&quot;, size = 0.5, width = 0.3, alpha=1)  + 
  labs(y = &quot;% of interface surface overall occupied by PD clusters&quot;) +
  scale_color_manual(values=c(&quot;#8B8B83&quot;)) +
  scale_fill_manual(values=c(&quot;#8B8B83&quot;)) +
  facet_grid(~Interface) +
  scale_y_continuous(limits= c(5,40), breaks = c(5,10,15,20,25,30,35,40)) +
  scale_shape_manual(values=c(19,17))</code></pre>
<p><img src="surfaces_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p><br></p>
</div>
<div id="calculating-the-median-surface-of-individual-clusters-as" class="section level1">
<h1>Calculating the median surface of individual clusters (as %)</h1>
<p><br></p>
<pre class="r"><code># to calculate the surface of individual clusters independently we don&#39;t need to subset the data

ggplot(clusters_unnested, aes(x= Method, y=perc, colour= Genotype, fill= Genotype)) +
  geom_violin(alpha=0.5)+ 
  ggbeeswarm::geom_quasirandom(aes(group=Genotype), colour=&quot;black&quot;, fill=&quot;black&quot;, size= 2, alpha=0.5, width=0.1, show.legend = FALSE, dodge.width = 0.9) +
  stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
               geom = &quot;crossbar&quot;, size = 0.5, width = 0.3, alpha=1)  + 
  labs(y = &quot;% of interface surface occupied by individual PD clusters&quot;) +
  scale_color_manual(values=c(&quot;#8B8B83&quot;)) +
  scale_fill_manual(values=c(&quot;#8B8B83&quot;)) +
  facet_grid(~Interface) +
  scale_y_log10()</code></pre>
<p><img src="surfaces_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p><br></p>
</div>
<div id="calculating-the-actual-surface-of-the-interface" class="section level1">
<h1>Calculating the actual surface of the interface</h1>
<p><br></p>
<p>In this part we try to relate the percentages we calculated in the <a href="#surf1">sections above</a> to the real surface areas (in um^2) of our cells. To do this we employ the second plugin developed for the Paterlini, Belevich et al. paper: the <em>Contacts3D</em> plugin. An earlier version of the plugin has actually been used in an earlier paper we published <a href="https://www.nature.com/articles/s41477-019-0429-5">Yan et al.(2019)</a></p>
<p><br></p>
</div>
<div id="run2" class="section level1">
<h1>Run the <em>ContactArea3D</em> plugin</h1>
<p><br> Make sure you have loaded your datasets and models as described in the <a href="preliminary.html">Preliminary Steps section</a>. In this case annotations are not required.</p>
<p>From the MIB interface go to the Plugins tab -&gt; Organelle Analysis -&gt; ContactArea3D. A user interface will appear with multiple fields to be filled in. There is also a help section available.</p>
<p>For “XY smoothing”, “XY sampling” and “Z sampling” we imput values of <em>5, 5 and 1</em>. This creates an appropriate level of surface smoothing for the surface we are trying to generate and ensures a good yet computationally feasible sampling of our models to generate the surface itself. Clicking “Save results in” enables you to store the surface area values and by pressing “Filename for export” you can ensure that the format is <em>.csv</em>. “Export contact To Imaris” enables to send the surface to Imaris for 3D rendering.</p>
<p>After pressing “Continue”, when the process has finished a new window will appear with the largest of surfaces calculated appearing in it.</p>
<div class="figure">
<img src="img/area.png" width="700" />

</div>
<p><br></p>
</div>
<div id="check-outputs" class="section level1">
<h1>Check outputs</h1>
<p><br></p>
<p>If the plugin has worked correctly and you followed the instructions to calculate the surfaces of the models your <em>Data_individual_cells</em> folder should now contain one additional files.</p>
<p>This is the output of the <em>ContactArea3D</em> plugin: a <i>*_ContactArea3D_wall.csv</i> file.</p>
<p>In the files one object with a certain surface shoud be listed in most cases. However, please note that in certain cases (such as cases where shifts in the images are present) multiple objects might be detected. This is just because the software can’t generate a single objects but rather produces two objects separated by the section where the image shift occurred. Small wall sections can also generate additional smaller objects</p>
<p><br> <img src="img/area_output.png" width="700" /></p>
<p><br></p>
<p>If you want to analyse multiple datasets at the same, as we will do here, the processes described above need to be repeated for each <em>.am</em> file.</p>
<p><br></p>
</div>
<div id="processing-the-surfaces-in-r" class="section level1">
<h1>Processing the surfaces in R</h1>
<p><br></p>
<pre class="r"><code># THIS SECTION IS HIDDEN AND ONLY REQUIRED FOR KNITTING PURPOSES
# BECAUSE WE DON&#39;T WANT TO SHOW SETWD FUNCTION (as the path would likely be different on the computer of a user, we mirror the first part of the script and run it in a hidden chunk. The chunk diplayed will actally be idle, showing the code but not run

setwd(&#39;./Data_individual_cells&#39;)

#first we read the files 
Col_area &lt;- list.files(path = &quot;.&quot;, pattern = &quot;ContactArea3D_wall.csv&quot;) %&gt;%   map_df(function(f){
        #this will print the dataset 
    print(f) 
    x &lt;- read_csv(f) %&gt;% 
      as.data.frame %&gt;% 
      mutate(DatasetFilename = f) %&gt;%
      mutate(Genotype = &quot;Col-0&quot;) %&gt;%
      mutate(Interface = &quot;PPP-EN&quot;) 
  })    

#we edit the text of the DatasetFilename column to clean it 
Col_area$DatasetFilename &lt;- gsub(&quot;_ContactArea3D_wall.csv&quot;, &quot;&quot;, Col_area$DatasetFilename)</code></pre>
<pre class="r"><code># IMPORTANT:
# the working directory is assumed to be the downloaded folder &quot;Data_individual_cells&quot; so paths are given relative to that. Make sure this is also the case in your R environment using the getwd and setwd

#first we read the files 
Col_area &lt;- list.files(path = &quot;.&quot;, pattern = &quot;ContactArea3D_wall.csv&quot;) %&gt;%   
  map_df(function(f){
        #this will print the dataset 
    print(f) 
    x &lt;- read_csv(f) %&gt;% 
      as.data.frame %&gt;% 
      mutate(DatasetFilename = f) %&gt;%
      mutate(Genotype = &quot;Col-0&quot;) %&gt;%
      mutate(Interface = &quot;PPP-EN&quot;) 
  })    

#we edit the text of the DatasetFilename column to clean it 
Col_area$DatasetFilename &lt;- gsub(&quot;_ContactArea3D_wall.csv&quot;, &quot;&quot;, Col_area$DatasetFilename)</code></pre>
<pre class="r"><code># because in some cases multiple objects were generated (despite having a single cellular interface) we merge those multiple objects into a single one
Col_area_corrected &lt;- Col_area %&gt;% group_by(Genotype, Interface, DatasetFilename) %&gt;% dplyr::summarise(total_surface = sum(SurfaceArea, na.rm = TRUE))

# we are going to clean the DatasetFilename column as we did elsewhere in this pipeline
# we are going to duplicate the dataset column first 
Col_area_corrected$Cell = Col_area_corrected$DatasetFilename

#in the dataset filename column we remove anything after _DNN
Col_area_corrected$DatasetFilename &lt;- gsub(&quot;_PPP.*&quot;,&quot;&quot;, Col_area_corrected$DatasetFilename)

# in the column cell we remove anything before the name of the cell
Col_area_corrected$Cell &lt;- gsub(&quot;.*PPP&quot;, &quot;PPP&quot;, Col_area_corrected$Cell)

# we plot it
Col_area_corrected %&gt;%
  ggplot(aes(x= Genotype, y=total_surface, colour= Genotype, fill= Genotype)) +
  stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
               geom = &quot;crossbar&quot;, size = 0.5, width = 0.3, alpha=1)  + 
  ggbeeswarm::geom_quasirandom(aes(shape=DatasetFilename), size= 4, alpha=0.5, width=0.1, show.legend = FALSE, dodge.width = 0.3) +
  labs(y = &quot;Surface area of the cell (um^2)&quot;) +
  theme(legend.position = &quot;none&quot;) +
  scale_color_manual(values=c(&quot;#8B8B83&quot;)) +
  scale_fill_manual(values=c(&quot;#8B8B83&quot;)) +
  facet_grid(~Interface) +
  scale_y_continuous(limits= c(60,130), breaks = c(60,70,80,90,100,110,120,130,140)) +
  scale_shape_manual(values=c(19,17))</code></pre>
<p><img src="surfaces_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p><br></p>
<p>Using the median value of the surface and the median values of the percentages that we obtained <a href="#surf1">above</a> we can manually get estimates in um^2 of the conductive surface in cells and of the surface of the single clusters.</p>
<p><br></p>
<p>You have now completed this section: we have calculated the surfaces occupied by the clusters on our interfaces of interest. In the <a href="wall.html">next section</a> we will ask questions about the wall environment plasmodesmata lie within.</p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
